# 使用包, Crate 和模块管理日益增长的项目

随着您编写的程序的规模变得越来越庞大, 如何组织您的代码也变得愈发重要.
将实现相关的功能的代码放在一起, 并把实现不同功能的代码区分开,
您将会更清楚该去何处寻找实现某一特定功能的的代码,
或者该去何处修改某一特定功能工作的方式.

在此之前我们编写的程序, 均位于一个文件的一个模块 (module) 中.
随着一个项目的不断发展, 您应该组织自己的代码, 例如将代码放在不同的模块,
以至不同的文件中. 一个包 (package) 可以包含若干个二进制 crate (binary crate),
并且可以选择性地包含一个库 crate (library crate). 随着包的不断增大,
您可以将其中的一些部分提取成为若干独立的 crate, 并将它们变成外部依赖.
本章将会介绍所有这些技巧. 至于逐步发展,
以至成为由一系列相互关联的包所组成的非常大的项目, Cargo 提供了 *工作空间*
(workspace) 的概念, 我们将会在第十四章的
["Cargo 工作空间"][workspaces]<!-- ignore --> 一节对此进行讲解.

我们也会讨论如何封装具体的实现细节, 这可以让您在一个更高的层次来复用程序代码:
在您实现了具体的某一操作后, 其它地方的代码便可以通过公开接口调用您的这部分代码,
而无需知晓该实现是如何工作的. 您在编写代码时即可定义:
哪些部分公开可被其他代码所使用, 哪些部分为私有的具体实现, 只有您有权修改.
这是另一种可以降低您需要记忆的细节的方式.

这里有一个相关的概念, 作用域 (scope): 我们编写出的代码处于层层嵌套的上下文语境中,
这就是作用域, 其中往往有一系列名称, 即是被定义 "在 (这个) 作用域中".
程序员或编译器在阅读, 编写以及编译代码时, 需要知道某个特定位置的某个特定名称,
是否引用着某个变量, 某个函数, 某个结构, 某个枚举, 某个模块, 某个常量, 
或者其它什么有意义的项目. 您尽可以创建作用域, 并且更改某个名称到作用域内部或外部. 
在同一个作用域中, 不同的项不能使用相同的名称; 现有工具一般能够发现这些命名冲突.

Rust 有一系列功能, 使得您可以管理您代码的组织形式, 例如您程序中哪些细节是公开的,
哪些细节是私有的, 以及哪些名称在何作用域中. 这些功能, 有些时候被统称为 *模块系统*
(module system), 包括:

* **包** (packages): Cargo 提供的一种功能, 可以让您构建, 测试, 以及分享 crate;
* **Crate**: 产出库或者可执行文件的模块集合 [^tree-of-modules];
* **模块** (modules) 和 **use**: 让您可以控制不同路径 (paths) 的组织结构,
  作用域, 以及私有性;
* **路径** (paths): 一种用来命名某一特定项目 (比如结构体, 函数或者模块) 的方式.

在本章中, 我们将会涵盖所有这些概念, 讨论它们之间是如何相互作用的,
并讲解该如何使用它们来管理作用域. 到最后, 您将收获对模块系统的扎实认知,
并熟练地在工作中使用作用域.

[workspaces]: ch14-03-cargo-workspaces.html

[^tree-of-modules]: 译者注: 原文为 "tree of modules", 直译为 "模块形成的树", 其中 "树" 一词意味着某种层次关系.
